# -*- coding: utf-8 -*-
"""QuizDNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OAhrtUNR_5ODkY-lQKZkH6t3CMc-UrA2
"""

import torch 
import torch.nn as nn
import torchvision
from torchsummary import summary
import torch.nn.functional as F

# x1 = Input
# x2 = Conv(x1)
# x3 = Conv(x1 + x2)
# x4 = MaxPooling(x1 + x2 + x3)
# x5 = Conv(x4)
# x6 = Conv(x4 + x5)
# x7 = Conv(x4 + x5 + x6)
# x8 = MaxPooling(x5 + x6 + x7)
# x9 = Conv(x8)
# x10 = Conv (x8 + x9)
# x11 = Conv (x8 + x9 + x10)
# x12 = GAP(x11)
# x13 = FC(x12)

class quizdnn(nn.Module):
    def __init__(self):
        super(quizdnn, self).__init__()

        #x1 = Input
        self.Tran1 = nn.Sequential(
            nn.Conv2d(in_channels=3, out_channels=32, kernel_size=(1, 1), padding=0, bias=False),nn.ReLU(),nn.BatchNorm2d(32)
        )


        #x2 = Conv(x1)
        # Convolution Block 1
        self.Conv1 = nn.Sequential(
            nn.Conv2d(in_channels=3, out_channels=32, kernel_size=(3, 3), padding=1, bias=False),nn.ReLU(),nn.BatchNorm2d(32)
        )

        #x3 = Conv(x1 + x2)
        self.Conv2 = nn.Sequential(
            nn.Conv2d(in_channels=32, out_channels=32, kernel_size=(3, 3), padding=1, bias=False),nn.ReLU(),nn.BatchNorm2d(32)
        ) 

        #x4 = MaxPooling(x1 + x2 + x3)

        self.Pool1 = nn.Sequential(
            nn.MaxPool2d(kernel_size=(2,2),stride=2)
        ) 

        self.Tran2 = nn.Sequential(
            nn.Conv2d(in_channels=32, out_channels=64, kernel_size=(1, 1), padding=0, bias=False),nn.ReLU(),nn.BatchNorm2d(64)
        )


        #x5 = Conv(x4)

        self.Conv3 = nn.Sequential(
            nn.Conv2d(in_channels=32, out_channels=64, kernel_size=(3, 3), padding=1, bias=False),nn.ReLU(),nn.BatchNorm2d(64)
        ) 

        #x6 = Conv(x4 + x5)

        self.Conv4 = nn.Sequential(
            nn.Conv2d(in_channels=64, out_channels=64, kernel_size=(3, 3), padding=1, bias=False),nn.ReLU(),nn.BatchNorm2d(64)
        ) 


        # x7 = Conv(x4 + x5 + x6)
        self.Conv5 = nn.Sequential(
            nn.Conv2d(in_channels=64, out_channels=64, kernel_size=(3, 3), padding=1, bias=False),nn.ReLU(),nn.BatchNorm2d(64)
        ) 

        # x8 = MaxPooling(x5 + x6 + x7)

        self.Pool2 = nn.Sequential(
            nn.MaxPool2d(kernel_size=(2,2),stride=2),
        ) 

        self.Tran3 = nn.Sequential(
            nn.Conv2d(in_channels=64, out_channels=128, kernel_size=(1, 1), padding=0, bias=False),nn.ReLU(),nn.BatchNorm2d(128)
        )



        # x9 = Conv(x8)
        self.Conv6 = nn.Sequential(
            nn.Conv2d(in_channels=64, out_channels=128, kernel_size=(3, 3), padding=1, bias=False),nn.ReLU(),nn.BatchNorm2d(128)
        ) 

        # x10 = Conv (x8 + x9)

        self.Conv7 = nn.Sequential(
            nn.Conv2d(in_channels=128, out_channels=128, kernel_size=(3, 3), padding=1, bias=False),nn.ReLU(),nn.BatchNorm2d(128)
        ) 

        # x11 = Conv (x8 + x9 + x10)

        self.Conv8 = nn.Sequential(
            nn.Conv2d(in_channels=128, out_channels=128, kernel_size=(3, 3), padding=1, bias=False),nn.ReLU(),nn.BatchNorm2d(128)
        ) 


        # x12 = GAP(x11)

        self.GAP = nn.Sequential(
            nn.AvgPool2d(kernel_size=7)
        )
         
        # x13 = FC(x12)

        self.FC = nn.Sequential(
            nn.Linear(128, 10, bias=False)
        ) 


       
    def forward(self,x):
          x1 = x
          x11 = self.Tran1(x)
          print(x11.shape)
          x2 = self.Conv1(x1)
          print(x2.shape)
          x3 = self.Conv2(x11 + x2)
          x4 = self.Pool1(x11 + x2 + x3)
          x44 = self.Tran2(x4)
          x5 = self.Conv3(x4)
          x6 = self.Conv4(x44 + x5)
          x7 = self.Conv5(x44 + x5 + x6)
          x8 = self.Pool2(x5 + x6 + x7)
          x88 = self.Tran3(x8)
          x9 = self.Conv6(x8)
          x10 =self.Conv7 (x88 + x9)
          x11 =self.Conv8 (x88 + x9 + x10)
          x12 =self.GAP(x11)

          x12 = x12.view(-1, 128)

          x13 =self.FC(x12)

          #x = x.view(-1, 10)
          #print(x.shape)
          return F.log_softmax(x13, dim=1)

# from torchsummary import summary

# model = quizdnn()

# summary(model, input_size=(3, 32, 32))